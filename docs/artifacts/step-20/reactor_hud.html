<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Brain Reactor Core HUD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Orbitron:wght@500;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-0: #04070d;
        --bg-1: #0a121f;
        --bg-2: #111d2d;
        --text: #d8f3ff;
        --cyan: #00e6ff;
        --green: #19ff75;
        --red: #ff335a;
        --amber: #ffbc42;
        --card: rgba(7, 21, 35, 0.65);
        --card-border: rgba(0, 230, 255, 0.22);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
        background:
          radial-gradient(1200px 500px at 10% -20%, rgba(0, 230, 255, 0.16), transparent 55%),
          radial-gradient(1000px 600px at 90% 120%, rgba(25, 255, 117, 0.13), transparent 55%),
          linear-gradient(140deg, var(--bg-0), var(--bg-1) 48%, var(--bg-2));
        color: var(--text);
        font-family: "JetBrains Mono", monospace;
      }

      .shell {
        max-width: 1320px;
        margin: 0 auto;
        padding: 18px 14px 24px;
      }

      .header {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px;
      }

      .title {
        font-family: "Orbitron", sans-serif;
        font-size: clamp(1.25rem, 3.6vw, 2.1rem);
        letter-spacing: 0.06em;
      }

      .subtitle {
        opacity: 0.75;
        font-size: 0.82rem;
      }

      .status-badge {
        padding: 7px 12px;
        border-radius: 999px;
        border: 1px solid var(--card-border);
        background: rgba(0, 16, 29, 0.65);
        font-size: 0.78rem;
      }

      .grid {
        margin-top: 14px;
        display: grid;
        gap: 12px;
        grid-template-columns: 1.35fr 1fr;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        backdrop-filter: blur(4px);
        overflow: hidden;
      }

      .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        font-size: 0.8rem;
        border-bottom: 1px solid rgba(0, 230, 255, 0.2);
      }

      .card-head strong {
        color: var(--cyan);
        font-family: "Orbitron", sans-serif;
        letter-spacing: 0.04em;
      }

      #coreWrap {
        position: relative;
        min-height: 420px;
      }

      #coreCanvas {
        display: block;
        width: 100%;
        height: 420px;
      }

      .core-overlay {
        position: absolute;
        left: 12px;
        bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 0.78rem;
      }

      .pill {
        border: 1px solid rgba(0, 230, 255, 0.28);
        border-radius: 999px;
        padding: 4px 10px;
        background: rgba(2, 12, 22, 0.72);
      }

      .panel-col {
        display: grid;
        gap: 12px;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        padding: 10px;
      }

      .metric {
        border: 1px solid rgba(0, 230, 255, 0.16);
        border-radius: 12px;
        padding: 8px;
        background: rgba(2, 15, 26, 0.5);
      }

      .metric-label {
        font-size: 0.72rem;
        opacity: 0.75;
      }

      .metric-value {
        margin-top: 6px;
        font-family: "Orbitron", sans-serif;
        font-size: 1.15rem;
      }

      .graph-canvas {
        width: 100%;
        height: 190px;
        display: block;
      }

      .protection {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(255, 20, 30, 0.08);
        pointer-events: none;
        z-index: 50;
      }

      .protection span {
        font-family: "Orbitron", sans-serif;
        padding: 14px 18px;
        border-radius: 999px;
        border: 1px solid rgba(255, 51, 90, 0.9);
        color: #fff;
        background: rgba(70, 0, 10, 0.64);
        box-shadow: 0 0 34px rgba(255, 51, 90, 0.48);
        animation: pulse 0.6s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        from {
          transform: scale(0.98);
          opacity: 0.68;
        }
        to {
          transform: scale(1.02);
          opacity: 1;
        }
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="header">
        <div>
          <div class="title">F20 Reactor Core HUD</div>
          <div class="subtitle">Brain Energy Flow Â· Budget Protection Console</div>
        </div>
        <div class="status-badge" id="runLabel">run: -</div>
      </div>

      <div class="grid">
        <section class="card">
          <div class="card-head">
            <strong>Holographic Token Gauge</strong>
            <span id="coreState">state: stable</span>
          </div>
          <div id="coreWrap">
            <canvas id="coreCanvas"></canvas>
            <div class="core-overlay">
              <span class="pill" id="promptGauge">Prompt 0/0</span>
              <span class="pill" id="completionGauge">Completion 0/0</span>
              <span class="pill" id="pressureGauge">Pressure 0%</span>
              <span class="pill" id="velocityGauge">Velocity 0 tok/s</span>
            </div>
          </div>
        </section>

        <div class="panel-col">
          <section class="card">
            <div class="card-head">
              <strong>Cost Pulse Line</strong>
              <span id="costHint">$0.00000000</span>
            </div>
            <canvas class="graph-canvas" id="costCanvas"></canvas>
          </section>

          <section class="card">
            <div class="card-head">
              <strong>Exploit / Explore Radar</strong>
              <span id="radarHint">Sector 7 Scanning...</span>
            </div>
            <canvas class="graph-canvas" id="radarCanvas"></canvas>
          </section>

          <section class="card">
            <div class="card-head">
              <strong>Telemetry</strong>
              <span id="asOfLabel">as_of: -</span>
            </div>
            <div class="metric-grid">
              <div class="metric">
                <div class="metric-label">Reactor State</div>
                <div class="metric-value" id="metricState">stable</div>
              </div>
              <div class="metric">
                <div class="metric-label">Protection</div>
                <div class="metric-value" id="metricProtection">OFF</div>
              </div>
              <div class="metric">
                <div class="metric-label">Explore Ratio</div>
                <div class="metric-value" id="metricExplore">0.00</div>
              </div>
              <div class="metric">
                <div class="metric-label">Fallback Count</div>
                <div class="metric-value" id="metricFallback">0</div>
              </div>
            </div>
          </section>
        </div>
      </div>
    </div>

    <div class="protection" id="protectionOverlay">
      <span>SYSTEM PROTECTION ACTIVATED</span>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

      const apiBase = new URLSearchParams(location.search).get("api") || "http://127.0.0.1:8765";
      const runId = new URLSearchParams(location.search).get("run_id") || "";
      const initialState = {
        pressure: 0,
        velocity: 0,
        state: "stable",
        protection_mode: false,
        explore_ratio: 0.3,
        exploit_ratio: 0.7,
        fallback_count: 0,
        prompt_tokens: 0,
        prompt_limit: 0,
        completion_tokens: 0,
        completion_limit: 0,
        cost_latest: 0,
        as_of: "",
        run_id: runId,
      };

      const targetState = { ...initialState };
      const smoothState = { ...initialState };
      let costSeries = [];

      const stateColors = {
        stable: 0x00e6ff,
        warning: 0xffbc42,
        critical: 0xff335a,
        blocked: 0xff335a,
      };

      const runLabel = document.getElementById("runLabel");
      const coreStateLabel = document.getElementById("coreState");
      const promptGauge = document.getElementById("promptGauge");
      const completionGauge = document.getElementById("completionGauge");
      const pressureGauge = document.getElementById("pressureGauge");
      const velocityGauge = document.getElementById("velocityGauge");
      const costHint = document.getElementById("costHint");
      const radarHint = document.getElementById("radarHint");
      const asOfLabel = document.getElementById("asOfLabel");
      const metricState = document.getElementById("metricState");
      const metricProtection = document.getElementById("metricProtection");
      const metricExplore = document.getElementById("metricExplore");
      const metricFallback = document.getElementById("metricFallback");
      const protectionOverlay = document.getElementById("protectionOverlay");

      const coreCanvas = document.getElementById("coreCanvas");
      const renderer = new THREE.WebGLRenderer({ canvas: coreCanvas, antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(42, 1, 0.1, 100);
      camera.position.set(0, 0.1, 4.4);
      scene.add(camera);

      const ambient = new THREE.AmbientLight(0x88aabb, 0.5);
      scene.add(ambient);
      const key = new THREE.PointLight(0x00e6ff, 1.6, 20);
      key.position.set(2.4, 1.7, 3.4);
      scene.add(key);
      const fill = new THREE.PointLight(0x19ff75, 0.6, 20);
      fill.position.set(-2.8, -1.3, 2.4);
      scene.add(fill);

      const coreMat = new THREE.MeshStandardMaterial({
        color: 0x0b2130,
        emissive: 0x00e6ff,
        emissiveIntensity: 0.45,
        metalness: 0.35,
        roughness: 0.3,
      });
      const core = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), coreMat);
      scene.add(core);

      const shell = new THREE.Mesh(
        new THREE.TorusGeometry(1.45, 0.08, 24, 100),
        new THREE.MeshStandardMaterial({
          color: 0x0d3850,
          emissive: 0x00e6ff,
          emissiveIntensity: 0.35,
          transparent: true,
          opacity: 0.82,
        }),
      );
      shell.rotation.x = Math.PI * 0.56;
      scene.add(shell);

      const particlesCount = 820;
      const positions = new Float32Array(particlesCount * 3);
      for (let i = 0; i < particlesCount; i += 1) {
        const r = 1.8 + Math.random() * 0.8;
        const a = Math.random() * Math.PI * 2;
        const h = (Math.random() - 0.5) * 2.2;
        positions[i * 3 + 0] = Math.cos(a) * r;
        positions[i * 3 + 1] = h;
        positions[i * 3 + 2] = Math.sin(a) * r;
      }
      const particlesGeo = new THREE.BufferGeometry();
      particlesGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const particles = new THREE.Points(
        particlesGeo,
        new THREE.PointsMaterial({
          color: 0x00e6ff,
          size: 0.028,
          transparent: true,
          opacity: 0.8,
        }),
      );
      scene.add(particles);

      const costCanvas = document.getElementById("costCanvas");
      const costCtx = costCanvas.getContext("2d");
      const radarCanvas = document.getElementById("radarCanvas");
      const radarCtx = radarCanvas.getContext("2d");

      const resize = () => {
        const w = coreCanvas.clientWidth;
        const h = coreCanvas.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        for (const canvas of [costCanvas, radarCanvas]) {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = Math.floor(canvas.clientWidth * dpr);
          canvas.height = Math.floor(canvas.clientHeight * dpr);
          const ctx = canvas.getContext("2d");
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
      };
      addEventListener("resize", resize);
      resize();

      function drawCostPulse() {
        const w = costCanvas.clientWidth;
        const h = costCanvas.clientHeight;
        costCtx.clearRect(0, 0, w, h);
        costCtx.fillStyle = "rgba(1,10,18,0.7)";
        costCtx.fillRect(0, 0, w, h);
        costCtx.strokeStyle = "rgba(0,230,255,0.22)";
        costCtx.lineWidth = 1;
        for (let y = 28; y < h; y += 28) {
          costCtx.beginPath();
          costCtx.moveTo(0, y);
          costCtx.lineTo(w, y);
          costCtx.stroke();
        }

        if (!costSeries.length) {
          return;
        }

        const sliced = costSeries.slice(-80);
        const max = Math.max(...sliced.map((x) => Number(x.value || 0)), 0.000001);
        const min = Math.min(...sliced.map((x) => Number(x.value || 0)), 0);
        const range = Math.max(0.000001, max - min);

        costCtx.beginPath();
        sliced.forEach((point, idx) => {
          const x = (idx / Math.max(1, sliced.length - 1)) * (w - 20) + 10;
          const v = Number(point.value || 0);
          const y = h - 12 - ((v - min) / range) * (h - 24);
          if (idx === 0) costCtx.moveTo(x, y);
          else costCtx.lineTo(x, y);
        });
        costCtx.strokeStyle = "rgba(0,230,255,0.95)";
        costCtx.lineWidth = 2.2;
        costCtx.stroke();

        costCtx.fillStyle = "rgba(255,51,90,0.9)";
        for (let i = 1; i < sliced.length; i += 1) {
          const prev = Number(sliced[i - 1].value || 0);
          const curr = Number(sliced[i].value || 0);
          if (curr > prev * 1.35 && curr > 0.0000001) {
            const x = (i / Math.max(1, sliced.length - 1)) * (w - 20) + 10;
            const y = h - 12 - ((curr - min) / range) * (h - 24);
            costCtx.beginPath();
            costCtx.arc(x, y, 3.2, 0, Math.PI * 2);
            costCtx.fill();
          }
        }
      }

      function drawRadar(t) {
        const w = radarCanvas.clientWidth;
        const h = radarCanvas.clientHeight;
        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.38;

        radarCtx.clearRect(0, 0, w, h);
        radarCtx.fillStyle = "rgba(1,10,18,0.74)";
        radarCtx.fillRect(0, 0, w, h);

        radarCtx.strokeStyle = "rgba(0,230,255,0.24)";
        radarCtx.lineWidth = 1;
        for (let i = 1; i <= 4; i += 1) {
          radarCtx.beginPath();
          radarCtx.arc(cx, cy, (radius * i) / 4, 0, Math.PI * 2);
          radarCtx.stroke();
        }

        const exploitAngle = Math.PI * 2 * Math.max(0, Math.min(1, smoothState.exploit_ratio));
        radarCtx.beginPath();
        radarCtx.moveTo(cx, cy);
        radarCtx.arc(cx, cy, radius, -Math.PI / 2, -Math.PI / 2 + exploitAngle, false);
        radarCtx.closePath();
        radarCtx.fillStyle = "rgba(0,230,255,0.34)";
        radarCtx.fill();

        radarCtx.beginPath();
        radarCtx.moveTo(cx, cy);
        radarCtx.arc(cx, cy, radius, -Math.PI / 2 + exploitAngle, -Math.PI / 2 + Math.PI * 2, false);
        radarCtx.closePath();
        radarCtx.fillStyle = "rgba(25,255,117,0.27)";
        radarCtx.fill();

        const scan = (t * 0.001) % (Math.PI * 2);
        radarCtx.beginPath();
        radarCtx.moveTo(cx, cy);
        radarCtx.lineTo(cx + Math.cos(scan) * radius, cy + Math.sin(scan) * radius);
        radarCtx.strokeStyle = "rgba(255,188,66,0.95)";
        radarCtx.lineWidth = 2;
        radarCtx.stroke();
      }

      function updateHud() {
        const p = Math.max(0, Math.min(1.3, smoothState.pressure));
        runLabel.textContent = `run: ${smoothState.run_id || "-"}`;
        coreStateLabel.textContent = `state: ${smoothState.state}`;
        promptGauge.textContent = `Prompt ${Math.round(smoothState.prompt_tokens)}/${Math.round(smoothState.prompt_limit)}`;
        completionGauge.textContent = `Completion ${Math.round(smoothState.completion_tokens)}/${Math.round(smoothState.completion_limit)}`;
        pressureGauge.textContent = `Pressure ${(p * 100).toFixed(1)}%`;
        velocityGauge.textContent = `Velocity ${smoothState.velocity.toFixed(2)} tok/s`;
        costHint.textContent = `$${Number(smoothState.cost_latest || 0).toFixed(8)}`;
        radarHint.textContent = "Sector 7 (Volatility Index) Scanning...";
        asOfLabel.textContent = `as_of: ${smoothState.as_of || "-"}`;
        metricState.textContent = smoothState.state;
        metricProtection.textContent = smoothState.protection_mode ? "ON" : "OFF";
        metricExplore.textContent = Number(smoothState.explore_ratio || 0).toFixed(2);
        metricFallback.textContent = `${Math.round(smoothState.fallback_count || 0)}`;
        protectionOverlay.style.display = smoothState.protection_mode ? "flex" : "none";
      }

      function applySnapshot(payload) {
        if (!payload || typeof payload !== "object") return;
        const reactor = payload.reactor || {};
        const core = reactor.core || {};
        const gauge = reactor.token_gauge || {};
        const pulse = reactor.cost_pulse || {};
        const radar = reactor.exploit_explore_radar || {};
        const fallback = reactor.fallback || {};
        const gauges = payload.gauges || {};

        targetState.pressure = Number((gauges.pressure && gauges.pressure.value) || core.pressure || 0);
        targetState.velocity = Number((gauges.velocity_tokens_per_sec && gauges.velocity_tokens_per_sec.value) || 0);
        targetState.state = String(core.state || payload.flags?.reactor_state || "stable");
        targetState.protection_mode = Boolean(core.protection_mode || payload.flags?.protection_mode);
        targetState.explore_ratio = Number(radar.explore_ratio || 0);
        targetState.exploit_ratio = Number(radar.exploit_ratio || 0);
        targetState.fallback_count = Number(fallback.count || 0);
        targetState.prompt_tokens = Number(gauge.prompt_tokens || 0);
        targetState.prompt_limit = Number(gauge.prompt_limit || 0);
        targetState.completion_tokens = Number(gauge.completion_tokens || 0);
        targetState.completion_limit = Number(gauge.completion_limit || 0);
        targetState.cost_latest = Number(pulse.latest_cost_usd || 0);
        targetState.as_of = String(payload.as_of || "");
        targetState.run_id = String(payload.run_id || targetState.run_id || "");

        const pulseSeries = payload.series && Array.isArray(payload.series.cost_pulse) ? payload.series.cost_pulse : [];
        costSeries = pulseSeries;
      }

      function render(t) {
        const mix = 0.11;
        for (const key of [
          "pressure",
          "velocity",
          "explore_ratio",
          "exploit_ratio",
          "fallback_count",
          "prompt_tokens",
          "prompt_limit",
          "completion_tokens",
          "completion_limit",
          "cost_latest",
        ]) {
          smoothState[key] += (targetState[key] - smoothState[key]) * mix;
        }
        smoothState.state = targetState.state;
        smoothState.protection_mode = targetState.protection_mode;
        smoothState.as_of = targetState.as_of;
        smoothState.run_id = targetState.run_id;

        const pressure = Math.max(0, Math.min(1.3, smoothState.pressure));
        core.scale.setScalar(0.95 + pressure * 0.16);
        core.rotation.y += 0.004 + pressure * 0.004;
        shell.rotation.z += 0.006 + pressure * 0.003;
        particles.rotation.y -= 0.001 + pressure * 0.0016;
        particles.material.opacity = 0.38 + pressure * 0.45;

        const color = stateColors[smoothState.state] || stateColors.stable;
        core.material.emissive.setHex(color);
        shell.material.emissive.setHex(color);
        key.color.setHex(color);
        key.intensity = 1.0 + pressure * 1.8;
        core.material.emissiveIntensity = 0.25 + pressure * 1.0;
        if (smoothState.protection_mode) {
          shell.material.opacity = 0.56 + Math.sin(t * 0.01) * 0.2;
        } else {
          shell.material.opacity = 0.82;
        }

        renderer.render(scene, camera);
        drawCostPulse();
        drawRadar(t);
        updateHud();

        requestAnimationFrame(render);
      }

      async function fetchSnapshot(id) {
        if (!id) return;
        try {
          const res = await fetch(`${apiBase}/api/runs/${encodeURIComponent(id)}/reactor_status`);
          if (!res.ok) return;
          const payload = await res.json();
          applySnapshot(payload);
        } catch {
          // Keep rendering with last known snapshot.
        }
      }

      function connectWs() {
        const protocol = apiBase.startsWith("https") ? "wss" : "ws";
        const host = apiBase.replace(/^https?:\/\//, "");
        const query = new URLSearchParams({
          replay: "15",
          include_reactor: "1",
          reactor_interval_sec: "1.0",
        });
        if (runId) query.set("run_id", runId);
        const ws = new WebSocket(`${protocol}://${host}/ws/live?${query.toString()}`);

        ws.onmessage = (evt) => {
          try {
            const row = JSON.parse(evt.data);
            if (row && row.event_type === "reactor.status" && row.payload) {
              applySnapshot(row.payload);
              return;
            }
            const eventRun = row && row.run_id ? row.run_id : row?.payload?.run_id;
            const activeRun = runId || eventRun;
            if (activeRun) {
              fetchSnapshot(activeRun);
            }
          } catch {
            // Ignore malformed frame
          }
        };
        ws.onclose = () => {
          setTimeout(connectWs, 1600);
        };
      }

      if (runId) {
        fetchSnapshot(runId);
      }
      connectWs();
      setInterval(() => {
        const active = targetState.run_id || runId;
        if (active) fetchSnapshot(active);
      }, 3000);
      requestAnimationFrame(render);
    </script>
  </body>
</html>
